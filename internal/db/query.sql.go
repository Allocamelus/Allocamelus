// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const acceptAllFollowRequests = `-- name: AcceptAllFollowRequests :exec
UPDATE UserFollows
SET accepted = true
WHERE followUserId = $1
  AND accepted = false
`

func (q *Queries) AcceptAllFollowRequests(ctx context.Context, followuserid int64) error {
	_, err := q.db.Exec(ctx, acceptAllFollowRequests, followuserid)
	return err
}

const acceptFollowRequest = `-- name: AcceptFollowRequest :exec
UPDATE UserFollows
SET accepted = true
WHERE userId = $1
  AND followUserId = $2
`

type AcceptFollowRequestParams struct {
	Userid       int64
	Followuserid int64
}

func (q *Queries) AcceptFollowRequest(ctx context.Context, arg AcceptFollowRequestParams) error {
	_, err := q.db.Exec(ctx, acceptFollowRequest, arg.Userid, arg.Followuserid)
	return err
}

const countFollowers = `-- name: CountFollowers :one
SELECT COUNT(userFollowId)
FROM UserFollows
WHERE followUserId = $1
  AND accepted = true
`

func (q *Queries) CountFollowers(ctx context.Context, followuserid int64) (int64, error) {
	row := q.db.QueryRow(ctx, countFollowers, followuserid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostCommentReplies = `-- name: CountPostCommentReplies :one
SELECT COUNT(*)
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.parent)
WHERE PCC.parent = $1
  /* PCC.parent != PCC.child prevents query from counting parent's self */
  AND PCC.parent != PCC.child
`

func (q *Queries) CountPostCommentReplies(ctx context.Context, parent int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPostCommentReplies, parent)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostCommentRepliesTotalDepth = `-- name: CountPostCommentRepliesTotalDepth :one
SELECT COUNT(*)
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.parent)
WHERE PCC.parent = $1
  AND PCC.depth <= $2
  AND PCC.parent != PCC.child
`

type CountPostCommentRepliesTotalDepthParams struct {
	Parent int64
	Depth  int64
}

func (q *Queries) CountPostCommentRepliesTotalDepth(ctx context.Context, arg CountPostCommentRepliesTotalDepthParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPostCommentRepliesTotalDepth, arg.Parent, arg.Depth)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostCommentsTopLevel = `-- name: CountPostCommentsTopLevel :one
SELECT COUNT(*)
FROM PostComments
WHERE postId = $1
  AND parent = 0
`

func (q *Queries) CountPostCommentsTopLevel(ctx context.Context, postid int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPostCommentsTopLevel, postid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostCommentsTotal = `-- name: CountPostCommentsTotal :one
SELECT COUNT(*)
FROM PostComments
WHERE postId = $1
`

func (q *Queries) CountPostCommentsTotal(ctx context.Context, postid int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPostCommentsTotal, postid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostCommentsTotalDepth = `-- name: CountPostCommentsTotalDepth :one
SELECT COUNT(*)
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.parent)
WHERE PC.postId = $1
  AND PCC.depth <= $2
  AND PC.parent = 0
`

type CountPostCommentsTotalDepthParams struct {
	Postid int64
	Depth  int64
}

func (q *Queries) CountPostCommentsTotalDepth(ctx context.Context, arg CountPostCommentsTotalDepthParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPostCommentsTotalDepth, arg.Postid, arg.Depth)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicPostsByUser = `-- name: CountPublicPostsByUser :one
SELECT COUNT(postId)
FROM Posts
WHERE published != 0
    AND userId = $1
`

func (q *Queries) CountPublicPostsByUser(ctx context.Context, userid int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicPostsByUser, userid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicPostsForUser = `-- name: CountPublicPostsForUser :one
SELECT COUNT(postId)
FROM Posts
WHERE Posts.userId IN (
    SELECT followUserId
    FROM (
        SELECT followUserId
        FROM UserFollows
        WHERE UserFollows.userId = $1
          AND accepted = true
      ) tmp
  )
  AND published != 0
  OR Posts.userId = $1
`

func (q *Queries) CountPublicPostsForUser(ctx context.Context, userid int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicPostsForUser, userid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserEvents = `-- name: CountUserEvents :one
SELECT COUNT(userEventId)
FROM UserEvents
WHERE eventType = $1
  AND userId = $2
  AND created > $3
`

type CountUserEventsParams struct {
	Eventtype int16
	Userid    int64
	Created   int64
}

func (q *Queries) CountUserEvents(ctx context.Context, arg CountUserEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserEvents, arg.Eventtype, arg.Userid, arg.Created)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deactivateOldUserAvatars = `-- name: DeactivateOldUserAvatars :exec
UPDATE UserAvatars
SET active = false
WHERE userAvatarId IN (
        SELECT userAvatarId
        FROM (
            SELECT userAvatarId
            FROM UserAvatars
            ORDER BY userAvatarId DESC
            OFFSET 1
          ) tmp
    )
  AND UserAvatars.userId = $1
  AND active = true
`

func (q *Queries) DeactivateOldUserAvatars(ctx context.Context, userid int64) error {
	_, err := q.db.Exec(ctx, deactivateOldUserAvatars, userid)
	return err
}

const deactivateUserAvatar = `-- name: DeactivateUserAvatar :exec
UPDATE UserAvatars
SET active = false
WHERE userID = $1
  AND active = true
`

func (q *Queries) DeactivateUserAvatar(ctx context.Context, userid int64) error {
	_, err := q.db.Exec(ctx, deactivateUserAvatar, userid)
	return err
}

const deleteOldSessions = `-- name: DeleteOldSessions :exec
DELETE FROM Sessions
WHERE expiration < $1
`

func (q *Queries) DeleteOldSessions(ctx context.Context, expiration int64) error {
	_, err := q.db.Exec(ctx, deleteOldSessions, expiration)
	return err
}

const deletePostComment = `-- name: DeletePostComment :exec
DELETE FROM PostComments AS PC
USING PostCommentClosures AS PCC
WHERE PC.postCommentId = PCC.child
  AND PCC.parent = $1
`

func (q *Queries) DeletePostComment(ctx context.Context, parent int64) error {
	_, err := q.db.Exec(ctx, deletePostComment, parent)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM Sessions
WHERE key = $1
`

func (q *Queries) DeleteSession(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, deleteSession, key)
	return err
}

const deleteUserAvatarByFile = `-- name: DeleteUserAvatarByFile :exec
DELETE FROM UserAvatars
WHERE fileType = $1
  AND hash = $2
`

type DeleteUserAvatarByFileParams struct {
	Filetype int32
	Hash     string
}

func (q *Queries) DeleteUserAvatarByFile(ctx context.Context, arg DeleteUserAvatarByFileParams) error {
	_, err := q.db.Exec(ctx, deleteUserAvatarByFile, arg.Filetype, arg.Hash)
	return err
}

const deleteUserToken = `-- name: DeleteUserToken :exec
DELETE FROM UserTokens
WHERE userTokenId = $1
`

func (q *Queries) DeleteUserToken(ctx context.Context, usertokenid int64) error {
	_, err := q.db.Exec(ctx, deleteUserToken, usertokenid)
	return err
}

const deleteUserTokenByUIDAndType = `-- name: DeleteUserTokenByUIDAndType :exec
DELETE FROM UserTokens
WHERE userId = $1
  AND tokenType = $2
`

type DeleteUserTokenByUIDAndTypeParams struct {
	Userid    int64
	Tokentype int16
}

func (q *Queries) DeleteUserTokenByUIDAndType(ctx context.Context, arg DeleteUserTokenByUIDAndTypeParams) error {
	_, err := q.db.Exec(ctx, deleteUserTokenByUIDAndType, arg.Userid, arg.Tokentype)
	return err
}

const followUser = `-- name: FollowUser :exec
INSERT INTO UserFollows (userId, followUserId, accepted, created)
VALUES ($1, $2, $3, $4)
`

type FollowUserParams struct {
	Userid       int64
	Followuserid int64
	Accepted     bool
	Created      int64
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) error {
	_, err := q.db.Exec(ctx, followUser,
		arg.Userid,
		arg.Followuserid,
		arg.Accepted,
		arg.Created,
	)
	return err
}

const getLatestPublicPostsByUser = `-- name: GetLatestPublicPostsByUser :many
SELECT postId,
    published,
    updated,
    content
FROM Posts
WHERE published != 0
    AND userId = $1
ORDER BY published DESC
LIMIT $3 OFFSET $2
`

type GetLatestPublicPostsByUserParams struct {
	Userid int64
	Offset int32
	Limit  int32
}

type GetLatestPublicPostsByUserRow struct {
	Postid    int64
	Published int64
	Updated   int64
	Content   string
}

func (q *Queries) GetLatestPublicPostsByUser(ctx context.Context, arg GetLatestPublicPostsByUserParams) ([]GetLatestPublicPostsByUserRow, error) {
	rows, err := q.db.Query(ctx, getLatestPublicPostsByUser, arg.Userid, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPublicPostsByUserRow
	for rows.Next() {
		var i GetLatestPublicPostsByUserRow
		if err := rows.Scan(
			&i.Postid,
			&i.Published,
			&i.Updated,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPublicPostsForUser = `-- name: GetLatestPublicPostsForUser :many
SELECT postId,
    userId,
    published,
    updated,
    content
FROM Posts
WHERE Posts.userId IN (
        SELECT followUserId
        FROM (
                SELECT followUserId
                FROM UserFollows
                WHERE UserFollows.userId = $1
                    AND accepted = true
            ) tmp
    )
    AND published != 0
    OR Posts.userId = $1
ORDER BY published DESC
LIMIT $3 OFFSET $2
`

type GetLatestPublicPostsForUserParams struct {
	Userid int64
	Offset int32
	Limit  int32
}

type GetLatestPublicPostsForUserRow struct {
	Postid    int64
	Userid    int64
	Published int64
	Updated   int64
	Content   string
}

func (q *Queries) GetLatestPublicPostsForUser(ctx context.Context, arg GetLatestPublicPostsForUserParams) ([]GetLatestPublicPostsForUserRow, error) {
	rows, err := q.db.Query(ctx, getLatestPublicPostsForUser, arg.Userid, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPublicPostsForUserRow
	for rows.Next() {
		var i GetLatestPublicPostsForUserRow
		if err := rows.Scan(
			&i.Postid,
			&i.Userid,
			&i.Published,
			&i.Updated,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldUserAvatars = `-- name: GetOldUserAvatars :many
SELECT UA.fileType,
  UA.hash
FROM UserAvatars AS UA
WHERE UA.userId = $1
  AND UA.active = false
  AND NOT EXISTS (
    SELECT useravatarid, userid, active, created, filetype, hash
    FROM UserAvatars AS UA2
    WHERE UA.hash = UA2.hash
      AND UA2.active = true
  )
`

type GetOldUserAvatarsRow struct {
	Filetype int32
	Hash     string
}

func (q *Queries) GetOldUserAvatars(ctx context.Context, userid int64) ([]GetOldUserAvatarsRow, error) {
	rows, err := q.db.Query(ctx, getOldUserAvatars, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOldUserAvatarsRow
	for rows.Next() {
		var i GetOldUserAvatarsRow
		if err := rows.Scan(&i.Filetype, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one
SELECT userId,
  created,
  published,
  updated,
  content
FROM Posts
WHERE postId = $1
LIMIT 1
`

type GetPostRow struct {
	Userid    int64
	Created   int64
	Published int64
	Updated   int64
	Content   string
}

func (q *Queries) GetPost(ctx context.Context, postid int64) (GetPostRow, error) {
	row := q.db.QueryRow(ctx, getPost, postid)
	var i GetPostRow
	err := row.Scan(
		&i.Userid,
		&i.Created,
		&i.Published,
		&i.Updated,
		&i.Content,
	)
	return i, err
}

const getPostCanView = `-- name: GetPostCanView :one
SELECT userId,
  published
FROM Posts
WHERE postId = $1
LIMIT 1
`

type GetPostCanViewRow struct {
	Userid    int64
	Published int64
}

func (q *Queries) GetPostCanView(ctx context.Context, postid int64) (GetPostCanViewRow, error) {
	row := q.db.QueryRow(ctx, getPostCanView, postid)
	var i GetPostCanViewRow
	err := row.Scan(&i.Userid, &i.Published)
	return i, err
}

const getPostComment = `-- name: GetPostComment :one
SELECT pc.postcommentid, pc.postid, pc.userid, pc.parent, pc.created, pc.updated, pc.content,
  PCC.depth
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.child)
WHERE PCC.child = $1
ORDER BY PCC.depth DESC
LIMIT 1
`

type GetPostCommentRow struct {
	Postcomment Postcomment
	Depth       int64
}

func (q *Queries) GetPostComment(ctx context.Context, child int64) (GetPostCommentRow, error) {
	row := q.db.QueryRow(ctx, getPostComment, child)
	var i GetPostCommentRow
	err := row.Scan(
		&i.Postcomment.Postcommentid,
		&i.Postcomment.Postid,
		&i.Postcomment.Userid,
		&i.Postcomment.Parent,
		&i.Postcomment.Created,
		&i.Postcomment.Updated,
		&i.Postcomment.Content,
		&i.Depth,
	)
	return i, err
}

const getPostCommentPostID = `-- name: GetPostCommentPostID :one
SELECT postId
FROM PostComments
WHERE postCommentId = $1
LIMIT 1
`

func (q *Queries) GetPostCommentPostID(ctx context.Context, postcommentid int64) (int64, error) {
	row := q.db.QueryRow(ctx, getPostCommentPostID, postcommentid)
	var postid int64
	err := row.Scan(&postid)
	return postid, err
}

const getPostCommentPostUserID = `-- name: GetPostCommentPostUserID :one
SELECT postId,
  userId
FROM PostComments
WHERE postCommentId = $1
LIMIT 1
`

type GetPostCommentPostUserIDRow struct {
	Postid int64
	Userid int64
}

func (q *Queries) GetPostCommentPostUserID(ctx context.Context, postcommentid int64) (GetPostCommentPostUserIDRow, error) {
	row := q.db.QueryRow(ctx, getPostCommentPostUserID, postcommentid)
	var i GetPostCommentPostUserIDRow
	err := row.Scan(&i.Postid, &i.Userid)
	return i, err
}

const getPostCommentReplies = `-- name: GetPostCommentReplies :many
SELECT pc.postcommentid, pc.postid, pc.userid, pc.parent, pc.created, pc.updated, pc.content,
  PCC.depth
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.child)
WHERE PCC.parent = $1
  AND PCC.depth <= $2
  AND PCC.parent != PCC.child
LIMIT $4 OFFSET $3
`

type GetPostCommentRepliesParams struct {
	Parent int64
	Depth  int64
	Offset int32
	Limit  int32
}

type GetPostCommentRepliesRow struct {
	Postcomment Postcomment
	Depth       int64
}

func (q *Queries) GetPostCommentReplies(ctx context.Context, arg GetPostCommentRepliesParams) ([]GetPostCommentRepliesRow, error) {
	rows, err := q.db.Query(ctx, getPostCommentReplies,
		arg.Parent,
		arg.Depth,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostCommentRepliesRow
	for rows.Next() {
		var i GetPostCommentRepliesRow
		if err := rows.Scan(
			&i.Postcomment.Postcommentid,
			&i.Postcomment.Postid,
			&i.Postcomment.Userid,
			&i.Postcomment.Parent,
			&i.Postcomment.Created,
			&i.Postcomment.Updated,
			&i.Postcomment.Content,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostCommentUserID = `-- name: GetPostCommentUserID :one
SELECT userId
FROM PostComments
WHERE postCommentId = $1
LIMIT 1
`

func (q *Queries) GetPostCommentUserID(ctx context.Context, postcommentid int64) (int64, error) {
	row := q.db.QueryRow(ctx, getPostCommentUserID, postcommentid)
	var userid int64
	err := row.Scan(&userid)
	return userid, err
}

const getPostComments = `-- name: GetPostComments :many
SELECT pc.postcommentid, pc.postid, pc.userid, pc.parent, pc.created, pc.updated, pc.content,
  PCC.depth
FROM PostComments PC
  JOIN PostCommentClosures PCC ON (PC.postCommentId = PCC.child)
WHERE PCC.parent IN (
    SELECT postCommentId
    FROM (
        SELECT postCommentId
        FROM PostComments
        WHERE PostComments.postId = $1
          AND parent = 0
        ORDER BY postCommentId DESC -- Newest first
        LIMIT $3 OFFSET $2
      ) tmp
  )
  AND PCC.depth <= $4
ORDER BY PC.postCommentId ASC -- Comments are flipped back for sorting
LIMIT $5
`

type GetPostCommentsParams struct {
	Postid  int64
	Offset  int32
	Limit   int32
	Depth   int64
	Limit_2 int32
}

type GetPostCommentsRow struct {
	Postcomment Postcomment
	Depth       int64
}

func (q *Queries) GetPostComments(ctx context.Context, arg GetPostCommentsParams) ([]GetPostCommentsRow, error) {
	rows, err := q.db.Query(ctx, getPostComments,
		arg.Postid,
		arg.Offset,
		arg.Limit,
		arg.Depth,
		arg.Limit_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostCommentsRow
	for rows.Next() {
		var i GetPostCommentsRow
		if err := rows.Scan(
			&i.Postcomment.Postcommentid,
			&i.Postcomment.Postid,
			&i.Postcomment.Userid,
			&i.Postcomment.Parent,
			&i.Postcomment.Created,
			&i.Postcomment.Updated,
			&i.Postcomment.Content,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostMedia = `-- name: GetPostMedia :many
SELECT PM.alt,
  PMF.width,
  PMF.height,
  PMF.hash
FROM PostMedia PM
  JOIN PostMediaFiles PMF ON (PM.postMediaFileId = PMF.postMediaFileId)
WHERE postId = $1
  AND active = true
ORDER BY postMediaId ASC
LIMIT 4
`

type GetPostMediaRow struct {
	Alt    string
	Width  int32
	Height int32
	Hash   string
}

func (q *Queries) GetPostMedia(ctx context.Context, postid int64) ([]GetPostMediaRow, error) {
	rows, err := q.db.Query(ctx, getPostMedia, postid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostMediaRow
	for rows.Next() {
		var i GetPostMediaRow
		if err := rows.Scan(
			&i.Alt,
			&i.Width,
			&i.Height,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostMediaFileIDByHash = `-- name: GetPostMediaFileIDByHash :one
SELECT postMediaFileId
FROM PostMediaFiles
WHERE hash = $1
LIMIT 1
`

func (q *Queries) GetPostMediaFileIDByHash(ctx context.Context, hash string) (int64, error) {
	row := q.db.QueryRow(ctx, getPostMediaFileIDByHash, hash)
	var postmediafileid int64
	err := row.Scan(&postmediafileid)
	return postmediafileid, err
}

const getPostPublishedStatus = `-- name: GetPostPublishedStatus :one
SELECT published
FROM Posts
WHERE postId = $1
LIMIT 1
`

func (q *Queries) GetPostPublishedStatus(ctx context.Context, postid int64) (int64, error) {
	row := q.db.QueryRow(ctx, getPostPublishedStatus, postid)
	var published int64
	err := row.Scan(&published)
	return published, err
}

const getPostUserID = `-- name: GetPostUserID :one
SELECT userId
FROM Posts
WHERE postId = $1
LIMIT 1
`

func (q *Queries) GetPostUserID(ctx context.Context, postid int64) (int64, error) {
	row := q.db.QueryRow(ctx, getPostUserID, postid)
	var userid int64
	err := row.Scan(&userid)
	return userid, err
}

const getPublicUser = `-- name: GetPublicUser :one
SELECT userName,
  name,
  bio,
  type,
  created
FROM Users
WHERE userId = $1
LIMIT 1
`

type GetPublicUserRow struct {
	Username string
	Name     string
	Bio      string
	Type     int16
	Created  int64
}

func (q *Queries) GetPublicUser(ctx context.Context, userid int64) (GetPublicUserRow, error) {
	row := q.db.QueryRow(ctx, getPublicUser, userid)
	var i GetPublicUserRow
	err := row.Scan(
		&i.Username,
		&i.Name,
		&i.Bio,
		&i.Type,
		&i.Created,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT data, expiration
FROM Sessions
WHERE key = $1
LIMIT 1
`

type GetSessionRow struct {
	Data       []byte
	Expiration int64
}

func (q *Queries) GetSession(ctx context.Context, key string) (GetSessionRow, error) {
	row := q.db.QueryRow(ctx, getSession, key)
	var i GetSessionRow
	err := row.Scan(&i.Data, &i.Expiration)
	return i, err
}

const getUserAuthKeyHash = `-- name: GetUserAuthKeyHash :one
SELECT authKeyHash
FROM UserKeys
WHERE userId = $1
ORDER BY userKeyId DESC
LIMIT 1
`

func (q *Queries) GetUserAuthKeyHash(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserAuthKeyHash, userid)
	var authkeyhash string
	err := row.Scan(&authkeyhash)
	return authkeyhash, err
}

const getUserAuthKeySalt = `-- name: GetUserAuthKeySalt :one
SELECT authKeySalt
FROM UserKeys
WHERE userId = $1
ORDER BY userKeyId DESC
LIMIT 1
`

func (q *Queries) GetUserAuthKeySalt(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserAuthKeySalt, userid)
	var authkeysalt string
	err := row.Scan(&authkeysalt)
	return authkeysalt, err
}

const getUserAvatarURLHash = `-- name: GetUserAvatarURLHash :one
SELECT hash
FROM UserAvatars
WHERE userId = $1
  AND active = true
ORDER BY userAvatarId DESC
LIMIT 1
`

func (q *Queries) GetUserAvatarURLHash(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserAvatarURLHash, userid)
	var hash string
	err := row.Scan(&hash)
	return hash, err
}

const getUserEmailByID = `-- name: GetUserEmailByID :one
SELECT email
FROM Users
WHERE userId = $1
LIMIT 1
`

func (q *Queries) GetUserEmailByID(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserEmailByID, userid)
	var email string
	err := row.Scan(&email)
	return email, err
}

const getUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT userId
FROM Users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserIDByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDByEmail, email)
	var userid int64
	err := row.Scan(&userid)
	return userid, err
}

const getUserIDByUserName = `-- name: GetUserIDByUserName :one
SELECT userId
FROM Users
WHERE userName = $1
LIMIT 1
`

func (q *Queries) GetUserIDByUserName(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDByUserName, username)
	var userid int64
	err := row.Scan(&userid)
	return userid, err
}

const getUserNameByID = `-- name: GetUserNameByID :one
SELECT userName FROM Users WHERE userId = $1 LIMIT 1
`

func (q *Queries) GetUserNameByID(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserNameByID, userid)
	var username string
	err := row.Scan(&username)
	return username, err
}

const getUserPermissions = `-- name: GetUserPermissions :one
SELECT permissions
FROM Users
WHERE userId = $1
LIMIT 1
`

func (q *Queries) GetUserPermissions(ctx context.Context, userid int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserPermissions, userid)
	var permissions int64
	err := row.Scan(&permissions)
	return permissions, err
}

const getUserPrivateArmoredKey = `-- name: GetUserPrivateArmoredKey :one
SELECT privateArmored
FROM UserKeys
WHERE userId = $1
ORDER BY userKeyId DESC
LIMIT 1
`

func (q *Queries) GetUserPrivateArmoredKey(ctx context.Context, userid int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserPrivateArmoredKey, userid)
	var privatearmored string
	err := row.Scan(&privatearmored)
	return privatearmored, err
}

const getUserPublicKeys = `-- name: GetUserPublicKeys :many
SELECT userKeyId,
  publicArmored
FROM UserKeys
WHERE userId = $1
  AND (
    replaced > $2
    OR replaced = false
  )
ORDER BY userKeyId DESC
`

type GetUserPublicKeysParams struct {
	Userid   int64
	Replaced int64
}

type GetUserPublicKeysRow struct {
	Userkeyid     int64
	Publicarmored string
}

func (q *Queries) GetUserPublicKeys(ctx context.Context, arg GetUserPublicKeysParams) ([]GetUserPublicKeysRow, error) {
	rows, err := q.db.Query(ctx, getUserPublicKeys, arg.Userid, arg.Replaced)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPublicKeysRow
	for rows.Next() {
		var i GetUserPublicKeysRow
		if err := rows.Scan(&i.Userkeyid, &i.Publicarmored); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserToken = `-- name: GetUserToken :one
SELECT userTokenId,
  userId,
  tokenType,
  token,
  expiration
FROM UserTokens
WHERE selector = $1
LIMIT 1
`

type GetUserTokenRow struct {
	Usertokenid int64
	Userid      int64
	Tokentype   int16
	Token       string
	Expiration  int64
}

func (q *Queries) GetUserToken(ctx context.Context, selector string) (GetUserTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserToken, selector)
	var i GetUserTokenRow
	err := row.Scan(
		&i.Usertokenid,
		&i.Userid,
		&i.Tokentype,
		&i.Token,
		&i.Expiration,
	)
	return i, err
}

const getUserType = `-- name: GetUserType :one
SELECT type
FROM Users
WHERE userId = $1
LIMIT 1
`

func (q *Queries) GetUserType(ctx context.Context, userid int64) (int16, error) {
	row := q.db.QueryRow(ctx, getUserType, userid)
	var type_ int16
	err := row.Scan(&type_)
	return type_, err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO Posts (userId, created, published, content)
VALUES ($1, $2, $3, $4) RETURNING postId
`

type InsertPostParams struct {
	Userid    int64
	Created   int64
	Published int64
	Content   string
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPost,
		arg.Userid,
		arg.Created,
		arg.Published,
		arg.Content,
	)
	var postid int64
	err := row.Scan(&postid)
	return postid, err
}

const insertPostComment = `-- name: InsertPostComment :one
INSERT INTO PostComments (
    postId,
    userId,
    parent,
    created,
    content
  )
VALUES ($1, $2, $3, $4, $5) RETURNING postCommentId
`

type InsertPostCommentParams struct {
	Postid  int64
	Userid  int64
	Parent  int64
	Created int64
	Content string
}

func (q *Queries) InsertPostComment(ctx context.Context, arg InsertPostCommentParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPostComment,
		arg.Postid,
		arg.Userid,
		arg.Parent,
		arg.Created,
		arg.Content,
	)
	var postcommentid int64
	err := row.Scan(&postcommentid)
	return postcommentid, err
}

const insertPostCommentClosureDeep = `-- name: InsertPostCommentClosureDeep :exec
INSERT INTO PostCommentClosures(parent, child, depth)
SELECT p.parent,
  c.child,
  p.depth + c.depth + 1
FROM PostCommentClosures p,
  PostCommentClosures c
WHERE p.child = $1
  AND c.parent = $2
`

type InsertPostCommentClosureDeepParams struct {
	Child  int64
	Parent int64
}

func (q *Queries) InsertPostCommentClosureDeep(ctx context.Context, arg InsertPostCommentClosureDeepParams) error {
	_, err := q.db.Exec(ctx, insertPostCommentClosureDeep, arg.Child, arg.Parent)
	return err
}

const insertPostCommentClosureSelf = `-- name: InsertPostCommentClosureSelf :exec
INSERT INTO PostCommentClosures(parent, child, depth)
VALUES ($1, $2, 0)
`

type InsertPostCommentClosureSelfParams struct {
	Parent int64
	Child  int64
}

func (q *Queries) InsertPostCommentClosureSelf(ctx context.Context, arg InsertPostCommentClosureSelfParams) error {
	_, err := q.db.Exec(ctx, insertPostCommentClosureSelf, arg.Parent, arg.Child)
	return err
}

const insertPostMedia = `-- name: InsertPostMedia :exec
INSERT INTO PostMedia (
    postId,
    added,
    active,
    alt,
    postMediaFileId
  )
VALUES ($1, $2, true, $3, $4)
`

type InsertPostMediaParams struct {
	Postid          int64
	Added           int64
	Alt             string
	Postmediafileid int64
}

func (q *Queries) InsertPostMedia(ctx context.Context, arg InsertPostMediaParams) error {
	_, err := q.db.Exec(ctx, insertPostMedia,
		arg.Postid,
		arg.Added,
		arg.Alt,
		arg.Postmediafileid,
	)
	return err
}

const insertPostMediaFile = `-- name: InsertPostMediaFile :one
INSERT INTO PostMediaFiles (
    created,
    fileType,
    width,
    height,
    hash,
    newHash
  )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING postMediaFileId
`

type InsertPostMediaFileParams struct {
	Created  int64
	Filetype int32
	Width    int32
	Height   int32
	Hash     string
	Newhash  string
}

func (q *Queries) InsertPostMediaFile(ctx context.Context, arg InsertPostMediaFileParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPostMediaFile,
		arg.Created,
		arg.Filetype,
		arg.Width,
		arg.Height,
		arg.Hash,
		arg.Newhash,
	)
	var postmediafileid int64
	err := row.Scan(&postmediafileid)
	return postmediafileid, err
}

const insertSession = `-- name: InsertSession :exec
INSERT INTO Sessions (
  key,
  data,
  expiration
)
VALUES ($1, $2, $3)
`

type InsertSessionParams struct {
	Key        string
	Data       []byte
	Expiration int64
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession, arg.Key, arg.Data, arg.Expiration)
	return err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO Users (
    userName,
    name,
    email,
    bio,
    type,
    permissions,
    created
  )
VALUES ($1, '', $2, '', $3, $4, $5) RETURNING userId
`

type InsertUserParams struct {
	Username    string
	Email       string
	Type        int16
	Permissions int64
	Created     int64
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.Username,
		arg.Email,
		arg.Type,
		arg.Permissions,
		arg.Created,
	)
	var userid int64
	err := row.Scan(&userid)
	return userid, err
}

const insertUserAvatar = `-- name: InsertUserAvatar :exec
INSERT INTO UserAvatars (userID, created, fileType, hash)
VALUES ($1, $2, $3, $4)
`

type InsertUserAvatarParams struct {
	Userid   int64
	Created  int64
	Filetype int32
	Hash     string
}

func (q *Queries) InsertUserAvatar(ctx context.Context, arg InsertUserAvatarParams) error {
	_, err := q.db.Exec(ctx, insertUserAvatar,
		arg.Userid,
		arg.Created,
		arg.Filetype,
		arg.Hash,
	)
	return err
}

const insertUserEvent = `-- name: InsertUserEvent :one
INSERT INTO UserEvents (userId, eventType, created, info)
VALUES ($1, $2, $3, $4) RETURNING userEventId
`

type InsertUserEventParams struct {
	Userid    int64
	Eventtype int16
	Created   int64
	Info      string
}

func (q *Queries) InsertUserEvent(ctx context.Context, arg InsertUserEventParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertUserEvent,
		arg.Userid,
		arg.Eventtype,
		arg.Created,
		arg.Info,
	)
	var usereventid int32
	err := row.Scan(&usereventid)
	return usereventid, err
}

const insertUserEventKey = `-- name: InsertUserEventKey :exec
INSERT INTO UserEventKeys (userEventId, userKeyId, infoKey)
VALUES ($1, $2, $3)
`

type InsertUserEventKeyParams struct {
	Usereventid int32
	Userkeyid   int64
	Infokey     string
}

func (q *Queries) InsertUserEventKey(ctx context.Context, arg InsertUserEventKeyParams) error {
	_, err := q.db.Exec(ctx, insertUserEventKey, arg.Usereventid, arg.Userkeyid, arg.Infokey)
	return err
}

const insertUserKey = `-- name: InsertUserKey :exec
INSERT INTO UserKeys (
    userId,
    created,
    authKeyHash,
    authKeySalt,
    publicArmored,
    privateArmored,
    recoveryKeyHash,
    recoveryArmored
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
  )
`

type InsertUserKeyParams struct {
	Userid          int64
	Created         int64
	Authkeyhash     string
	Authkeysalt     string
	Publicarmored   string
	Privatearmored  string
	Recoverykeyhash string
	Recoveryarmored string
}

func (q *Queries) InsertUserKey(ctx context.Context, arg InsertUserKeyParams) error {
	_, err := q.db.Exec(ctx, insertUserKey,
		arg.Userid,
		arg.Created,
		arg.Authkeyhash,
		arg.Authkeysalt,
		arg.Publicarmored,
		arg.Privatearmored,
		arg.Recoverykeyhash,
		arg.Recoveryarmored,
	)
	return err
}

const insertUserToken = `-- name: InsertUserToken :exec
INSERT INTO UserTokens (
    userId,
    tokenType,
    selector,
    token,
    created,
    expiration
  )
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertUserTokenParams struct {
	Userid     int64
	Tokentype  int16
	Selector   string
	Token      string
	Created    int64
	Expiration int64
}

func (q *Queries) InsertUserToken(ctx context.Context, arg InsertUserTokenParams) error {
	_, err := q.db.Exec(ctx, insertUserToken,
		arg.Userid,
		arg.Tokentype,
		arg.Selector,
		arg.Token,
		arg.Created,
		arg.Expiration,
	)
	return err
}

const isFollowing = `-- name: IsFollowing :one
SELECT accepted
FROM UserFollows
WHERE userId = $1
  AND followUserId = $2
`

type IsFollowingParams struct {
	Userid       int64
	Followuserid int64
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFollowing, arg.Userid, arg.Followuserid)
	var accepted bool
	err := row.Scan(&accepted)
	return accepted, err
}

const listFollowRequests = `-- name: ListFollowRequests :many
SELECT userId
FROM UserFollows
WHERE followUserId = $1
  AND accepted = false
`

func (q *Queries) ListFollowRequests(ctx context.Context, followuserid int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, listFollowRequests, followuserid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var userid int64
		if err := rows.Scan(&userid); err != nil {
			return nil, err
		}
		items = append(items, userid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowers = `-- name: ListFollowers :many
SELECT userId
FROM UserFollows
WHERE followUserId = $1
  AND accepted = true
`

func (q *Queries) ListFollowers(ctx context.Context, followuserid int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, listFollowers, followuserid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var userid int64
		if err := rows.Scan(&userid); err != nil {
			return nil, err
		}
		items = append(items, userid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowing = `-- name: ListFollowing :many
SELECT followUserId
FROM UserFollows
WHERE userId = $1
  AND accepted = true
`

func (q *Queries) ListFollowing(ctx context.Context, userid int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, listFollowing, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var followuserid int64
		if err := rows.Scan(&followuserid); err != nil {
			return nil, err
		}
		items = append(items, followuserid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postMediaHashCheck = `-- name: PostMediaHashCheck :one
SELECT hash
FROM PostMediaFiles
WHERE hash = $1
  OR newHash = $1
LIMIT 1
`

func (q *Queries) PostMediaHashCheck(ctx context.Context, hash string) (string, error) {
	row := q.db.QueryRow(ctx, postMediaHashCheck, hash)
	err := row.Scan(&hash)
	return hash, err
}

const publishPost = `-- name: PublishPost :exec
UPDATE Posts
SET published = $1
WHERE postId = $2
`

type PublishPostParams struct {
	Published int64
	Postid    int64
}

func (q *Queries) PublishPost(ctx context.Context, arg PublishPostParams) error {
	_, err := q.db.Exec(ctx, publishPost, arg.Published, arg.Postid)
	return err
}

const sessionExist = `-- name: SessionExist :one
SELECT EXISTS(
    SELECT key, data, expiration
    FROM Sessions
    WHERE key = $1
  )
`

func (q *Queries) SessionExist(ctx context.Context, key string) (bool, error) {
	row := q.db.QueryRow(ctx, sessionExist, key)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM UserFollows
WHERE userId = $1
  AND followUserId = $2
`

type UnfollowUserParams struct {
	Userid       int64
	Followuserid int64
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error {
	_, err := q.db.Exec(ctx, unfollowUser, arg.Userid, arg.Followuserid)
	return err
}

const updatePostCommentContent = `-- name: UpdatePostCommentContent :exec
UPDATE PostComments
SET updated = $1,
  content = $2
WHERE postCommentId = $3
`

type UpdatePostCommentContentParams struct {
	Updated       int64
	Content       string
	Postcommentid int64
}

func (q *Queries) UpdatePostCommentContent(ctx context.Context, arg UpdatePostCommentContentParams) error {
	_, err := q.db.Exec(ctx, updatePostCommentContent, arg.Updated, arg.Content, arg.Postcommentid)
	return err
}

const updatePostContent = `-- name: UpdatePostContent :exec
UPDATE Posts
SET updated = $1,
  content = $2
WHERE postId = $3
`

type UpdatePostContentParams struct {
	Updated int64
	Content string
	Postid  int64
}

func (q *Queries) UpdatePostContent(ctx context.Context, arg UpdatePostContentParams) error {
	_, err := q.db.Exec(ctx, updatePostContent, arg.Updated, arg.Content, arg.Postid)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE Sessions
SET data = $1,
  expiration = $2
WHERE key = $3
`

type UpdateSessionParams struct {
	Data       []byte
	Expiration int64
	Key        string
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.Data, arg.Expiration, arg.Key)
	return err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE Users
SET bio = $1
WHERE userId = $2
`

type UpdateUserBioParams struct {
	Bio    string
	Userid int64
}

func (q *Queries) UpdateUserBio(ctx context.Context, arg UpdateUserBioParams) error {
	_, err := q.db.Exec(ctx, updateUserBio, arg.Bio, arg.Userid)
	return err
}

const updateUserName = `-- name: UpdateUserName :exec
UPDATE Users
SET name = $1
WHERE userId = $2
`

type UpdateUserNameParams struct {
	Name   string
	Userid int64
}

func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) error {
	_, err := q.db.Exec(ctx, updateUserName, arg.Name, arg.Userid)
	return err
}

const updateUserPermissions = `-- name: UpdateUserPermissions :exec
UPDATE Users
SET permissions = $1
WHERE userId = $2
`

type UpdateUserPermissionsParams struct {
	Permissions int64
	Userid      int64
}

func (q *Queries) UpdateUserPermissions(ctx context.Context, arg UpdateUserPermissionsParams) error {
	_, err := q.db.Exec(ctx, updateUserPermissions, arg.Permissions, arg.Userid)
	return err
}

const updateUserType = `-- name: UpdateUserType :exec
UPDATE Users
SET type = $1
WHERE userId = $2
`

type UpdateUserTypeParams struct {
	Type   int16
	Userid int64
}

func (q *Queries) UpdateUserType(ctx context.Context, arg UpdateUserTypeParams) error {
	_, err := q.db.Exec(ctx, updateUserType, arg.Type, arg.Userid)
	return err
}

const userHasAvatar = `-- name: UserHasAvatar :one
SELECT EXISTS(
    SELECT useravatarid, userid, active, created, filetype, hash
    FROM UserAvatars
    WHERE userId = $1
      AND active = true
  )
`

func (q *Queries) UserHasAvatar(ctx context.Context, userid int64) (bool, error) {
	row := q.db.QueryRow(ctx, userHasAvatar, userid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userTokenSelectorExist = `-- name: UserTokenSelectorExist :one
SELECT EXISTS(
    SELECT usertokenid, userid, tokentype, selector, token, created, expiration
    FROM UserTokens
    WHERE selector = $1
  )
`

func (q *Queries) UserTokenSelectorExist(ctx context.Context, selector string) (bool, error) {
	row := q.db.QueryRow(ctx, userTokenSelectorExist, selector)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const validateUserEmail = `-- name: ValidateUserEmail :one
SELECT EXISTS(
    SELECT userid, username, name, email, bio, type, permissions, created
    FROM Users
    WHERE email = $1
  )
`

func (q *Queries) ValidateUserEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, validateUserEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const validateUserName = `-- name: ValidateUserName :one
SELECT EXISTS(
    SELECT userid, username, name, email, bio, type, permissions, created
    FROM Users
    WHERE userName = $1
  )
`

func (q *Queries) ValidateUserName(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, validateUserName, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
